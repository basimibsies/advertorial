import type { AdminApiContext } from "@shopify/shopify-app-remix/server";

export interface Product {
  id: string;
  title: string;
  handle: string;
  description?: string;
  featuredImage?: string;
}

export async function getProducts(admin: AdminApiContext): Promise<Product[]> {
  const response = await admin.graphql(
    `#graphql
      query getProducts($first: Int!) {
        products(first: $first) {
          edges {
            node {
              id
              title
              handle
              description
              featuredImage {
                url
              }
            }
          }
        }
      }`,
    {
      variables: {
        first: 50,
      },
    },
  );

  const data = await response.json();
  return (
    data.data?.products?.edges?.map((edge: any) => ({
      id: edge.node.id,
      title: edge.node.title,
      handle: edge.node.handle,
      description: edge.node.description,
      featuredImage: edge.node.featuredImage?.url,
    })) || []
  );
}

export async function getThemeSettings(
  admin: AdminApiContext,
): Promise<{ primaryColor?: string; fontFamily?: string }> {
  try {
    const response = await admin.graphql(
      `#graphql
        query getTheme {
          themes(first: 1) {
            edges {
              node {
                id
                name
              }
            }
          }
        }`,
    );

    return {
      primaryColor: undefined,
      fontFamily: undefined,
    };
  } catch (error) {
    console.error("Error fetching theme settings:", error);
    return {};
  }
}

/**
 * Ensures the advertorial content metafield definition exists.
 * This metafield stores the generated HTML on each page.
 */
async function ensureMetafieldDefinition(admin: AdminApiContext): Promise<void> {
  // Check if the definition already exists
  const checkResponse = await admin.graphql(
    `#graphql
      query {
        metafieldDefinitions(
          first: 1,
          ownerType: PAGE,
          namespace: "advertorial",
          key: "content"
        ) {
          edges {
            node {
              id
            }
          }
        }
      }`,
  );

  const checkData = await checkResponse.json();
  if (checkData.data?.metafieldDefinitions?.edges?.length > 0) {
    return; // Already exists
  }

  // Create the metafield definition
  const createResponse = await admin.graphql(
    `#graphql
      mutation metafieldDefinitionCreate($definition: MetafieldDefinitionInput!) {
        metafieldDefinitionCreate(definition: $definition) {
          createdDefinition {
            id
          }
          userErrors {
            field
            message
          }
        }
      }`,
    {
      variables: {
        definition: {
          name: "Advertorial Content",
          namespace: "advertorial",
          key: "content",
          type: "multi_line_text_field",
          ownerType: "PAGE",
          description: "HTML content for advertorial pages generated by the Advertorial app",
        },
      },
    },
  );

  const createData = await createResponse.json();
  if (createData.data?.metafieldDefinitionCreate?.userErrors?.length > 0) {
    console.error(
      "Metafield definition errors:",
      createData.data.metafieldDefinitionCreate.userErrors,
    );
  }
}

/**
 * Creates a Shopify page with the advertorial content stored as a metafield.
 * The page uses the store's theme and the theme app extension renders the content.
 * This approach matches how GemPages/Replo publish pages â€” content lives in the
 * theme with full access to headers, footers, and store styles.
 *
 * @param shop - The shop domain (e.g. store-name.myshopify.com) so we can build the live storefront URL.
 */
export async function createShopifyPage(
  admin: AdminApiContext,
  shop: string,
  title: string,
  htmlContent: string,
  handle?: string,
): Promise<{ id: string; url: string }> {
  // Ensure the metafield definition exists
  await ensureMetafieldDefinition(admin);

  // Generate a handle from title if not provided
  const pageHandle =
    handle ||
    title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "")
      .substring(0, 50);

  const response = await admin.graphql(
    `#graphql
      mutation pageCreate($page: PageCreateInput!) {
        pageCreate(page: $page) {
          page {
            id
            title
            handle
          }
          userErrors {
            field
            message
          }
        }
      }`,
    {
      variables: {
        page: {
          title,
          handle: pageHandle,
          body: htmlContent, // Keep HTML in body as fallback for themes without the extension
          isPublished: true,
          metafields: [
            {
              namespace: "advertorial",
              key: "content",
              value: htmlContent,
              type: "multi_line_text_field",
            },
          ],
        },
      },
    },
  );

  const data = await response.json();

  if (data.data?.pageCreate?.userErrors?.length > 0) {
    const errors = data.data.pageCreate.userErrors;
    throw new Error(
      `Failed to create page: ${errors.map((e: any) => e.message).join(", ")}`,
    );
  }

  const page = data.data?.pageCreate?.page;
  if (!page) {
    throw new Error("Failed to create page: No page returned");
  }

  // Full storefront URL so "View live page" opens the store, not the app
  const storefrontHost = shop.startsWith("http") ? shop : `https://${shop}`;
  return {
    id: page.id,
    url: `${storefrontHost}/pages/${page.handle}`,
  };
}

/**
 * Updates an existing Shopify page's content (both body and metafield).
 *
 * @param shop - The shop domain for building the live storefront URL.
 */
export async function updateShopifyPage(
  admin: AdminApiContext,
  shop: string,
  pageId: string,
  title: string,
  htmlContent: string,
): Promise<{ url: string }> {
  const response = await admin.graphql(
    `#graphql
      mutation pageUpdate($id: ID!, $page: PageUpdateInput!) {
        pageUpdate(id: $id, page: $page) {
          page {
            id
            title
            handle
          }
          userErrors {
            field
            message
          }
        }
      }`,
    {
      variables: {
        id: pageId,
        page: {
          title,
          body: htmlContent,
          metafields: [
            {
              namespace: "advertorial",
              key: "content",
              value: htmlContent,
              type: "multi_line_text_field",
            },
          ],
        },
      },
    },
  );

  const data = await response.json();

  if (data.data?.pageUpdate?.userErrors?.length > 0) {
    const errors = data.data.pageUpdate.userErrors;
    throw new Error(
      `Failed to update page: ${errors.map((e: any) => e.message).join(", ")}`,
    );
  }

  const page = data.data?.pageUpdate?.page;
  const storefrontHost = shop.startsWith("http") ? shop : `https://${shop}`;
  return {
    url: page?.handle ? `${storefrontHost}/pages/${page.handle}` : "",
  };
}

import type { AdminApiContext } from "@shopify/shopify-app-remix/server";

export interface Product {
  id: string;
  title: string;
  handle: string;
  description?: string;
  featuredImage?: string;
}

export interface BrandSettings {
  primaryColor: string;
  secondaryColor: string;
  backgroundColor: string;
  textColor: string;
  headerFont: string;
  bodyFont: string;
}

export async function getProducts(admin: AdminApiContext): Promise<Product[]> {
  const response = await admin.graphql(
    `#graphql
      query getProducts($first: Int!) {
        products(first: $first) {
          edges {
            node {
              id
              title
              handle
              description
              featuredImage {
                url
              }
            }
          }
        }
      }`,
    {
      variables: {
        first: 50,
      },
    },
  );

  const data = await response.json();
  return (
    data.data?.products?.edges?.map((edge: any) => ({
      id: edge.node.id,
      title: edge.node.title,
      handle: edge.node.handle,
      description: edge.node.description,
      featuredImage: edge.node.featuredImage?.url,
    })) || []
  );
}

/**
 * Returns brand settings with sensible defaults.
 * Users can customize colors in the wizard's Brand step.
 * TODO: Add auto-detection from theme settings_data.json when API version supports it.
 */
export async function getBrandSettings(
  _admin: AdminApiContext,
): Promise<BrandSettings> {
  return {
    primaryColor: "#000000",
    secondaryColor: "#555555",
    backgroundColor: "#ffffff",
    textColor: "#1a1a1a",
    headerFont: "system-ui, -apple-system, sans-serif",
    bodyFont: "system-ui, -apple-system, sans-serif",
  };
}

/**
 * Ensures the advertorial content metafield definition exists.
 * This metafield stores the generated HTML on each page.
 */
async function ensureMetafieldDefinition(admin: AdminApiContext): Promise<void> {
  // Check if the definition already exists
  const checkResponse = await admin.graphql(
    `#graphql
      query {
        metafieldDefinitions(
          first: 1,
          ownerType: PAGE,
          namespace: "advertorial",
          key: "content"
        ) {
          edges {
            node {
              id
            }
          }
        }
      }`,
  );

  const checkData = await checkResponse.json();
  if (checkData.data?.metafieldDefinitions?.edges?.length > 0) {
    return; // Already exists
  }

  // Create the metafield definition
  const createResponse = await admin.graphql(
    `#graphql
      mutation metafieldDefinitionCreate($definition: MetafieldDefinitionInput!) {
        metafieldDefinitionCreate(definition: $definition) {
          createdDefinition {
            id
          }
          userErrors {
            field
            message
          }
        }
      }`,
    {
      variables: {
        definition: {
          name: "Advertorial Content",
          namespace: "advertorial",
          key: "content",
          type: "multi_line_text_field",
          ownerType: "PAGE",
          description: "HTML content for advertorial pages generated by the Advertorial app",
        },
      },
    },
  );

  const createData = await createResponse.json();
  if (createData.data?.metafieldDefinitionCreate?.userErrors?.length > 0) {
    console.error(
      "Metafield definition errors:",
      createData.data.metafieldDefinitionCreate.userErrors,
    );
  }
}

/**
 * Fetches the shop's primary domain (custom domain if set, otherwise myshopify.com).
 * This ensures advertorial URLs use the brand's real domain (e.g. https://gruns.co)
 * instead of the default .myshopify.com URL.
 */
export async function getPrimaryDomain(
  admin: AdminApiContext,
  shopFallback: string,
): Promise<string> {
  try {
    const response = await admin.graphql(
      `#graphql
        query {
          shop {
            primaryDomain {
              url
            }
          }
        }`,
    );
    const data = await response.json();
    const domainUrl = data.data?.shop?.primaryDomain?.url;
    if (domainUrl) {
      // primaryDomain.url returns something like "https://gruns.co"
      return domainUrl.replace(/\/$/, ""); // strip trailing slash
    }
  } catch (error) {
    console.error("Error fetching primary domain, falling back to shop:", error);
  }
  // Fallback to myshopify.com domain
  return shopFallback.startsWith("http") ? shopFallback : `https://${shopFallback}`;
}

/**
 * Creates a Shopify page with the advertorial content stored as a metafield.
 * The page uses the store's theme and the theme app extension renders the content.
 * This approach matches how GemPages/Replo publish pages — content lives in the
 * theme with full access to headers, footers, and store styles.
 *
 * Uses the shop's primary domain (custom domain) for the live URL so brands see
 * their real URL (e.g. https://gruns.co/pages/first-order-benefits).
 */
export async function createShopifyPage(
  admin: AdminApiContext,
  shop: string,
  title: string,
  htmlContent: string,
  handle?: string,
): Promise<{ id: string; url: string }> {
  // Ensure the metafield definition exists
  await ensureMetafieldDefinition(admin);

  // Generate a handle from the real title (for readable URLs)
  const baseHandle =
    handle ||
    title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "")
      .substring(0, 50);

  // Try creating the page, and if the handle is taken, retry with a unique suffix
  let pageHandle = baseHandle;
  let attempts = 0;
  let page: { id: string; title: string; handle: string } | null = null;

  while (attempts < 3) {
    const response = await admin.graphql(
      `#graphql
        mutation pageCreate($page: PageCreateInput!) {
          pageCreate(page: $page) {
            page {
              id
              title
              handle
            }
            userErrors {
              field
              message
            }
          }
        }`,
      {
        variables: {
          page: {
            title,
            handle: pageHandle,
            body: htmlContent, // Keep HTML in body as fallback for themes without the extension
            isPublished: true,
            metafields: [
              {
                namespace: "advertorial",
                key: "content",
                value: htmlContent,
                type: "multi_line_text_field",
              },
            ],
          },
        },
      },
    );

    const data = await response.json();
    const userErrors = data.data?.pageCreate?.userErrors || [];

    // Check if the handle is taken — retry with a unique suffix
    const handleTaken = userErrors.some(
      (e: any) => e.field?.includes("handle") && /taken/i.test(e.message),
    );

    if (handleTaken) {
      attempts++;
      const suffix = Date.now().toString(36).slice(-4);
      pageHandle = `${baseHandle}-${suffix}`.substring(0, 60);
      continue;
    }

    if (userErrors.length > 0) {
      throw new Error(
        `Failed to create page: ${userErrors.map((e: any) => e.message).join(", ")}`,
      );
    }

    page = data.data?.pageCreate?.page;
    break;
  }

  if (!page) {
    throw new Error("Failed to create page: Handle is already taken. Please try a different title.");
  }

  // Use the shop's primary/custom domain for the live URL
  const storefrontHost = await getPrimaryDomain(admin, shop);
  return {
    id: page.id,
    url: `${storefrontHost}/pages/${page.handle}`,
  };
}

/**
 * Updates an existing Shopify page's content (both body and metafield).
 *
 * @param shop - The shop domain for building the live storefront URL.
 */
export async function updateShopifyPage(
  admin: AdminApiContext,
  shop: string,
  pageId: string,
  title: string,
  htmlContent: string,
): Promise<{ url: string }> {
  const response = await admin.graphql(
    `#graphql
      mutation pageUpdate($id: ID!, $page: PageUpdateInput!) {
        pageUpdate(id: $id, page: $page) {
          page {
            id
            title
            handle
          }
          userErrors {
            field
            message
          }
        }
      }`,
    {
      variables: {
        id: pageId,
        page: {
          title,
          body: htmlContent,
          metafields: [
            {
              namespace: "advertorial",
              key: "content",
              value: htmlContent,
              type: "multi_line_text_field",
            },
          ],
        },
      },
    },
  );

  const data = await response.json();

  if (data.data?.pageUpdate?.userErrors?.length > 0) {
    const errors = data.data.pageUpdate.userErrors;
    throw new Error(
      `Failed to update page: ${errors.map((e: any) => e.message).join(", ")}`,
    );
  }

  const page = data.data?.pageUpdate?.page;
  const storefrontHost = await getPrimaryDomain(admin, shop);
  return {
    url: page?.handle ? `${storefrontHost}/pages/${page.handle}` : "",
  };
}
